/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 8.0.0   2017-10-19

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "main.h"
#include "stm32f7xx.h"
#include "stm32f7xx_hal.h"
#include "arm_math.h"
#include "arm_const_structs.h"
#include <stdio.h>
#include <math.h>

#define BUFFER_SIZE	2048
#define	FFT_SIZE	BUFFER_SIZE / 2


/* Private macro */
/* Private variables */
UART_HandleTypeDef huart6;
__IO ITStatus UartReady = RESET;
extern float32_t V_waveform[BUFFER_SIZE];
extern float32_t I_waveform[BUFFER_SIZE];
float32_t testOutput[FFT_SIZE];
float32_t phase_data[FFT_SIZE];
uint8_t txBuffer[FFT_SIZE*5];


/* Global variables */
uint32_t fftSize = 1024;
uint32_t ifftFlag = 0;
uint32_t doBitReverse = 1;


/* Reference index at which max energy of bin occurs */
uint32_t refIndex = 213;
uint32_t testIndex = 0;

/* Private function prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART6_UART_Init(void);
static void convert_from_fp2uint8(uint8_t* txBuff, float32_t* fft_output);
static void convert_to_amplitude(float32_t* data);
static void compute_fft_phase(float32_t* data_in, float32_t* data_out);
static void compute_Hanning_window(float32_t* data);
static void clean_tx_buffer(uint8_t* buffer);


/* Private functions */


/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */

void _Error_Handler(char * file, int line)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}



/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{

	arm_status status = ARM_MATH_SUCCESS;
	float32_t maxValue;

	HAL_Init();
	SystemClock_Config();


	MX_GPIO_Init();
	MX_USART6_UART_Init();


	/* compute Hann windowing */
	//compute_Hanning_window(I_waveform);

	/* COMPUTES THE FFT USING THE DUMMIE DATA */
	arm_cfft_f32(&arm_cfft_sR_f32_len1024, I_waveform, ifftFlag, doBitReverse);


	/* Process the data through the complex magnitude module for caltulating
	the magnitude at each bin */
	arm_cmplx_mag_f32(I_waveform, testOutput, FFT_SIZE);

	/* NOTES */
	/* Una vez obtenida la magnitud, para calcular la AMPLITUD debemos
	 * dividir la magnitud por el n de ptos de la fft (en este caso
	 * 1024) y posteriormente multiplicar el resultado por dos. */
	//convert_to_amplitude(testOutput);

	/* NOTES */
	/* In order to compute the Impedance from voltage and current values
	 * is necessary to divide V amplitude / I amplitude for the |Z|.
	 * The phases must be substracted : Z ph = V ph - I ph */

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(testOutput, FFT_SIZE, &maxValue, &testIndex);

	//if(testIndex != refIndex){
	//	status = ARM_MATH_TEST_FAILURE;

	//}

	if(status != ARM_MATH_SUCCESS){
		while(1){

		};
	}


	/* Convert the FFT compute to uint8 to send it using serialCOM */
	convert_from_fp2uint8(txBuffer, testOutput);


	/* Transmit the FFT computation to the PC */
	if(HAL_UART_Transmit_IT(&huart6, txBuffer, sizeof(txBuffer)) != HAL_OK){
		 Error_Handler();
	}



	/* Wait for the end of the transfer */
	while(UartReady != SET){

	}

	/* COMPUTE PHASE */
	/* clean the tx buffer */
	clean_tx_buffer(txBuffer);

	compute_fft_phase(I_waveform, phase_data);


	/* Convert the phase compute to uint8 to send it using serialCOM */
	convert_from_fp2uint8(txBuffer, phase_data);

	/* Transmit the phase */
	if(HAL_UART_Transmit_IT(&huart6, txBuffer, sizeof(txBuffer)) != HAL_OK){
		 Error_Handler();
	}



	/* Infinite loop */
	while (1)
	{

	}
}



/** System Clock Configuration
*/
void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

    /**Configure the main internal regulator output voltage
    */
  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  /* *Initializes the CPU, AHB and APB busses clocks */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART6;
  PeriphClkInitStruct.Usart6ClockSelection = RCC_USART6CLKSOURCE_SYSCLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  /**Configure the Systick interrupt time
  */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

  /**Configure the Systick
  */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}

/* USART6 init function */
static void MX_USART6_UART_Init(void)
{

  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  huart6.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}


/** Configure pins as
        * Analog
        * Input
        * Output
        * EVENT_OUT
        * EXTI
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

}






void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
{
	/* Set transmission flag: transfer complete*/
	if(UartHandle->Instance == USART6){
		UartReady = SET;
    }

}



/**
  * @brief  Rx Transfer completed callback
  * @param  UartHandle: UART handle
  * @note   This example shows a simple way to report end of DMA Rx transfer, and
  *         you can add your own implementation.
  * @retval None
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
	/* Set transmission flag: transfer complete*/
	if(UartHandle->Instance == USART6){
	    UartReady = SET;
	}


}


/* Convierte el valor float32 a 4 bytes para su envío a través
 * del serialCOM. */
static void convert_from_fp2uint8(uint8_t* txBuff, float32_t* fft_output){
	uint32_t i;
	int32_t temp;
	uint32_t j = 0;

	for(i = 0; i < FFT_SIZE; i++){

        temp = (int32_t)(fft_output[i] * 1000);		/* OJO, puede que asi haya problemas de overflow en temp */
        txBuff[j] = temp;
        txBuff[j+1] = temp >> 8;
        txBuff[j+2] = temp >> 16;
        txBuff[j+3] = temp >> 24;
        j += 4;
	}
}

/* Computa el valor de amplitud a partir de la
 * magnitud de la señal. */
static void convert_to_amplitude(float32_t* data){
	uint32_t i;

	for(i = 0; i < FFT_SIZE; i++){
		data[i] = 2 * (data[i] / FFT_SIZE);
	}
}


/* Computa valor de la fase a partir del calculo de la FFT */
static void compute_fft_phase(float32_t* data_in, float32_t* data_out){

	uint32_t i;
	uint32_t j = 0;

	for(i = 0; i < FFT_SIZE; i++){
		data_out[i] = atan2(data_in[j+1], data_in[j]); // OJO está en radianes
		j += 2;
	}
}




static void clean_tx_buffer(uint8_t* buffer){
	uint32_t i;

	for(i = 0; i < FFT_SIZE*5; i++){
		buffer[i] = 0;
	}
}


/* WINDOWS ------------------------------------------------- */
/* HANNING */
static void compute_Hanning_window(float32_t* data){
	uint32_t i;

	for(i = 0; i < BUFFER_SIZE; i++ ){
		float32_t multiplier = 0.5 * (1 - cos(2*PI*i/BUFFER_SIZE));
		data[i] = multiplier * data[i];

	}
}


/* RECTANGLE */
// TODO



/* HAMMING */
// TODO
static void compute_Hamming_window(float32_t* data){
	uint32_t i;

	for(i = 0; i < BUFFER_SIZE; i++){
		float32_t multiplier = 0.54 + (0.46 * cos(2*PI*i/BUFFER_SIZE));
		data[i] = multiplier * data[i];
	}
}

/* KAISER */
// TODO


/* BARTLETT */
// TODO



/* BLACKMAN */
// TODO
static void compute_Blackman_window(float32_t* data){
	uint32_t i;

	for(i = 0; i < BUFFER_SIZE; i++){
		float32_t multiplier = 0.42 + 0.5 * cos(2*PI*i/BUFFER_SIZE) + 0.08 * cos(4*PI*i/BUFFER_SIZE);
		data[i] = multiplier * data[i];
	}
}




